---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.0
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
# %config InlineBackend.figure_format='retina'
from IPython.display import display, HTML
display(HTML("<style>.container { width:95% !important; }</style>"))

from qubic import fibtools as ft
import fitting as fit
from importlib import reload

rc('figure',figsize=(20,6))
rc('font',size=12)

```

```{python}
#### Simulate input true "sky"
npix = 50
xpix = np.linspace(0,1,npix)

x0 = 0.5
maxy = 1.
α = -maxy / (x0-x0**2)
β = - α
amp = 1.
w0 = 0.1
ph = 0.3

truey = α*xpix**2 + β*xpix + amp*np.sin(xpix/w0+2*np.pi * ph)

plot(xpix, truey, label='True Sky')
xlabel('pixel')
ylabel('sky')
legend()
###########

```

```{python}
#np.random.seed(42)

###### Simulate observations including intercalibration
ndet = 60
nsamples = 100

###### Noise:
# Uniform noise
#sig = np.zeros(ndet) + 1e-2
# Variable noise across detectors
sig = 1e-2*(np.random.rand(ndet)+0.5)

H = np.zeros((ndet*nsamples, npix))
for i in range(npix):
    H[:,i] = np.random.randint(0,2, size=nsamples*ndet)

# nnn = nsamples // npix
# H = np.zeros((ndet*nsamples, npix))
# ### We want each pixel to be seen by all detectors
# for i in range(npix):
#     seenpix = np.zeros((ndet, nsamples))
#     for k in range(nnn): 
#         seenpix[:, k*npix+i] = 1
#         H[:,i] = np.ravel(seenpix)
    
intercal = np.append([1], (np.random.rand(ndet-1)+0.5))
alltod_intercal = np.dot(H, truey)
alltod = alltod_intercal.copy()
alltod_noiseless = alltod_intercal.copy()
for k in range(ndet):
    alltod_noiseless[k*nsamples:(k+1)*nsamples] *= intercal[k]
    alltod[k*nsamples:(k+1)*nsamples] *= intercal[k]
    alltod[k*nsamples:(k+1)*nsamples] += np.random.randn(nsamples)*sig[k]
#########################


print(np.std(np.reshape(alltod, (ndet, nsamples)), axis=1))

```

# Full Fit with Minuit

```{python}
class simulate_signal_intercal:
    def __init__(self, xpix, ndet, nsamples, H):
        self.xpix = xpix
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
    def __call__(self, x, sky_and_intercal):
        sky = sky_and_intercal[:len(self.xpix)]
        intercal = sky_and_intercal[len(self.xpix):]
        alltod = np.dot(self.H, sky)
        for k in range(self.ndet):
            alltod[k*self.nsamples:(k+1)*self.nsamples] *= intercal[k]
        return alltod


myH = simulate_signal_intercal(xpix, ndet, nsamples, H)

guess_sky = np.append(np.zeros(len(xpix)), np.ones(ndet))

sigmas = np.ones(len(alltod))
for k in range(ndet):
    sigmas[k*nsamples:(k+1)*nsamples] *= sig[k]

xxx = np.zeros(len(alltod))   # not used
data = fit.Data(xxx, alltod, sigmas, myH)
m, ch2, ndf = data.fit_minuit(guess_sky, fixpars = [len(xpix)])

mymap = m.values[:len(xpix)]
myintercals = m.values[len(xpix):]
mytod_th = myH(0, m.values)
chi2_ana = np.sum( ((mytod_th-alltod)/sigmas)**2)


print('Minuit says : chi2={} ndf={}'.format(ch2, ndf))
print('============================')
print('My Chi2 = {}'.format(chi2_ana))
print('The number of unknowns is: {}'.format(npix + ndet -1))
print('The number of points is: {}'.format(len(alltod)))
print('The ndf={}'.format(len(alltod)-(npix+ndet-1)))





subplot(2,2,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,2,2)
plot(xpix, mymap - truey, label='Residuals σ={0:5.3g}'.format(np.std(mymap - truey)))
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,2,3)
plot(intercal, label='True Intercals')
plot(myintercals, 'ro', label='reconstructed intercals')
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,2,4)
plot(myintercals-intercal, label='Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)))
xlabel('Det')
ylabel('Intercal')
legend()

tight_layout()


print()
print('RMS Residuals')
print('          M')
print('    Map.        Inter     ')
print('   {0:5.3g}   {1:5.3g}'.format(np.std(mymap - truey), np.std(myintercals-intercal)))

```

# Fit with Minuit + Analytical for intercals


We have data from $n_d$ detectors that observe a sky $\vec{s}$ through an instrument modeled by the operator $H$. Each detector has its own intercalibration.

So the perfectly intercalibrated data writes:
    $$ \vec{D} = H\vec{s} + \vec{n}$$
And the maximum likelihood solution would be:
    $$\hat{\vec{s}} = \left(H^t N^{-1} H\right)^{-1} H^t N^{-1} \vec{D}$$
    
But in reality we measure $\vec{d}$ which is not intercalibrated:
$$\vec{d}=\vec{D} A$$ where A is unknown...

So we proceed with the "inverse problem" approach:
$$\vec{d}=\vec{D} A = H \vec{s} A+\vec{n}$$

We vary $A$ and $\vec{s}$ and minimize:
$$\chi^2(A,\vec{s}) = \left(H\vec{s}A-\vec{d}\right)^t N^{-1}\left(H\vec{s}A-\vec{d}\right)$$
the solution is obtained by solving:
$$\frac{d\chi^2}{dA^t} = 0 = \vec{s}^t H^t N^{-1} H \vec{s}A - \vec{s}^t H^t N^{-1}\vec{d}$$
$$\Rightarrow~~~~ A= \left(\vec{s}^t H^t N^{-1} H \vec{s}\right)^{-1} \vec{s}^t H^t N^{-1}\vec{d}$$

So, at each step of the conjugate gradient (at each call to Minuit), we will test a sky $\vec{s}_i$ that correpsonds to "test"-intercalibrated data $\vec{D}_i = H\vec{s}_i$. We will compute at each of those steps:
$$A_i = \left(\vec{D}_i^t N^{-1}\vec{D}_i\right) \vec{D}_i^t N^{-1} \vec{d}$$
which allows to compute the corresponding $\chi^2$ as:
$$ \chi^2 = \left(\vec{D}_i A_i-\vec{d}\right)^t N^{-1}\left(\vec{D}_i A_i -\vec{d}\right)$$
and we minimize it only with respect to $\vec{s}$.

Once we have converged on $\hat{\vec{s}}$, the intercalibrations will be obtained by:
$$ \hat{\vec{D}} = H\hat{\vec{s}}$$
and
$$ \hat{A} = \left(\hat{\vec{D}}^t N^{-1}\hat{\vec{D}}\right)^{-1} \hat{\vec{D}}^t N^{-1} \vec{d}$$


### In practice:
If $N$ is dense it is possibly a large problem...

- if $N\propto \mathbb{1}$ the problem is completely simplified and $N$ disappears:
    - $\vec{D}_i = H\vec{s}_i$
    - $A_i = \left(\vec{D}^t\vec{D}\right)^{-1}\vec{D}^t \vec{d}$
    - $\chi^2 = \| \vec{D}_i A_i -\vec{d}\|^2$
    
- If $N$ is diagonal: $N^{-1} = \vec{w}\mathbb{1}$
    - $\vec{D}_i = H\vec{s}_i$
    - $A_i = \left(\vec{D}^t\vec{w}\vec{D}\right)^{-1}\vec{D}^t \vec{w}\vec{d}$
    - $\chi^2 = \|\vec{\sqrt{w}}\cdot\left(\vec{D}_i A_i -\vec{d}\right)\|^2$



# My current inmplementation (that seems suboptimal -> my $N^{-1}$ is not well implemented)

```{python}
reload(fit)



class simulate_signal_intercal:
    def __init__(self, xpix, ndet, nsamples, H, d, w):
        self.xpix = xpix
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
        self.d = np.reshape(d, (ndet, nsamples))
        self.w = np.reshape(w, (ndet, nsamples))
    def __call__(self, x, sky):
        D, intercal = self.give_intercals(sky)
        for k in range(self.ndet):
            D[k,:] *= intercal[k]
        return np.ravel(D)
    def give_intercals(self, sky):
        ### We remove the first detector from the fit as its intercalibration is forced to 1
        D = (np.reshape(np.dot(self.H, sky), (self.ndet, self.nsamples)))
        myD = D[1:,:]
        myw = self.w[1:,:]# * 0 + 1
        w = np.reshape(myw, (self.ndet-1, self.nsamples))
        matrix = (myD*w) @ myD.T
        intercal_rec = np.append(1, np.diag((np.linalg.inv(matrix) @ (myD*w)) @ self.d[1:,:].T))
        return D, intercal_rec

sigmas = np.ones(len(alltod))
for k in range(ndet):
    sigmas[k*nsamples:(k+1)*nsamples] *= sig[k]

#### Fit
myH = simulate_signal_intercal(xpix, ndet, nsamples, H, alltod, 1./sigmas**2)
guess_sky = np.ones(len(xpix))
xxx = np.zeros(len(alltod))   # not used
data = fit.Data(xxx, alltod, sigmas, myH)
m, ch2, ndf = data.fit_minuit(guess_sky)
mytod_th = myH(0, m.values)
chi2_ana = np.sum( ((mytod_th-alltod)/sigmas)**2)




print('Minuit says : chi2={} ndf={}'.format(ch2, ndf))
print('But we know it forgets the {} variables we fit analytically, so it should say {}'.format(ndet-1, ndf-(ndet-1)))
print('============================')
print('My Chi2 = {}'.format(chi2_ana))
print('The number of unknowns is: {}'.format(npix + ndet -1))
print('The number of points is: {}'.format(len(alltod)))
print('The ndf={}'.format(len(alltod)-(npix+ndet-1)))
print('============================')
print('With True Sky')

mytod_true = myH(0, truey)
chi2_true = np.sum( ((mytod_true-alltod)/sigmas)**2)
print('Chi2 True = {}'.format(chi2_true))

mymap2 = np.array(m.values)
myresult2, myintercals2 = myH.give_intercals(m.values)

subplot(2,3,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap2, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,3,2)
plot(xpix, mymap2 - truey, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(mymap2 - truey)))
plot(xpix, mymap - truey, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(mymap - truey)), alpha=0.5)
xlabel('pixel')
ylabel('sky')
legend(fontsize=10)

subplot(2,3,3)
a = fit.myhist(mymap2 - truey, label='Minuit + Ana Residuals')
a = fit.myhist(mymap - truey, label='Full Minuit Residuals')

subplot(2,3,4)
plot(intercal, label='True Intercals')
plot(myintercals2, 'ro', label='reconstructed intercals')
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,5)
plot(myintercals2-intercal, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(myintercals2-intercal)))
plot(myintercals-intercal, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)), alpha=0.5)
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,6)
a = fit.myhist(myintercals2-intercal, label='Minuit + Ana Residuals')
a = fit.myhist(myintercals-intercal, label='Full Minuit Residuals')

tight_layout()

print()
print('RMS Residuals')
print('                   M+A                    M')
print('              Map.      Inter.      Map.        Inter     ')
print('            {0:5.3g}   {1:5.3g}    {2:5.3g}   {3:5.3g}'.format(np.std(mymap2 - truey), np.std(myintercals2-intercal), np.std(mymap - truey), np.std(myintercals-intercal)))

```

```{python}
mytod_true = myH(0, truey)
chi2_true = np.sum( ((mytod_true-alltod)/sigmas)**2)
print('Chi2 with the True sky',chi2_true)
print()

myD_true, myintercals_true = myH.give_intercals(truey)
myD_fit, myintercals_fit = myH.give_intercals(m.values)

print('Intercalibrates TOD difference')
print('Init - myH(true)   RMS=',np.std(np.reshape(alltod_intercal, (ndet, nsamples)) - myD_true))
print('Init - myH(fit)   RMS=',np.std(np.reshape(alltod_intercal, (ndet, nsamples)) - myD_fit))

print()
print('Intercal differences')
print('Init - myH(true)   RMS=',np.std(myintercals_true-intercal))
print('Init - myH(fit)   RMS=',np.std(myintercals_fit-intercal))
plot(myintercals_true-intercal)
plot(myintercals_fit-intercal)

### These two are very similar because even when you have the perfectly right sky, when calculating analytically the intercals, 
# you calulate it against the noisy TOD => extra noise
```

- The extra noise we see on the intercalibration is also present when we calculate the intercalibrations with the true sky as an input. This comes from the fact that the measured TOD is involved in the intercal expression (last term). If this term is replaced by the noiseless TOD then the=is extra noise vanishes.
- So I suspect that my problem is due to a bad implementation of the w weighting. Maybe just muliplying as I do is not valid.

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

# Below are some shitty trials

```{python}
# N = np.diag(sig**2)
# subplot(1,2,1)
# imshow(N)

# Ninv = np.diag(1./sig**2)
# matrix = D @ (D.T @ myNinv)
# invmatrix = np.linalg.inv(matrix)
# print(np.shape(matrix))

# ic = np.append(1, np.diag(invmatrix @ D @ (d.T @ myNinv)))

```

```{python}
# reload(fit)



# class simulate_signal_intercal:
#     def __init__(self, xpix, ndet, nsamples, H, d, w):
#         self.xpix = xpix
#         self.ndet = ndet
#         self.nsamples = nsamples
#         self.H = H
#         self.d = np.reshape(d, (ndet, nsamples))
#         self.w = w*0+1
#     def __call__(self, x, sky):
#         D, intercal = self.give_intercals(sky)
#         for k in range(self.ndet):
#             D[k,:] *= intercal[k]
#         return np.ravel(D)
#     def give_intercals(self, sky):
#         ### We remove the first detector from the fit as its intercalibration is forced to 1
#         D = (np.reshape(np.dot(self.H, sky), (self.ndet, self.nsamples)))
#         myD = D[1:,:]
#         myd = self.d[1:,:]
#         invmatrix = np.linalg.inv(myD @ (myD.T @ np.diag(self.w[1:])))
#         intercal_rec = np.append(1, np.diag(invmatrix @ myD @ (myd.T @ invmatrix)))
# #         invmatrix = np.linalg.inv(D @ (D.T @ np.diag(self.w)))
# #         intercal_rec = np.diag(invmatrix @ D @ (self.d.T @ invmatrix))
# #         intercal_rec = intercal_rec / intercal_rec[0]
#         return D, intercal_rec    
    
# #### Fit
# myH = simulate_signal_intercal(xpix, ndet, nsamples, H, alltod, 1./sig**2)
# guess_sky = np.ones(len(xpix))
# xxx = np.zeros(len(alltod))   # not used
# data = fit.Data(xxx, alltod, sigmas, myH)
# m, ch2, ndf = data.fit_minuit(guess_sky)
# mytod_th = myH(0, m.values)
# chi2_ana = np.sum( ((mytod_th-alltod)/sigmas)**2)




# print('Minuit says : chi2={} ndf={}'.format(ch2, ndf))
# print('But we know it forgets the {} variables we fit analytically, so it should say {}'.format(ndet-1, ndf-(ndet-1)))
# print('============================')
# print('My Chi2 = {}'.format(chi2_ana))
# print('The number of unknowns is: {}'.format(npix + ndet -1))
# print('The number of points is: {}'.format(len(alltod)))
# print('The ndf={}'.format(len(alltod)-(npix+ndet-1)))
# print('============================')
# print('With True Sky')

# mytod_true = myH(0, truey)
# chi2_true = np.sum( ((mytod_true-alltod)/sigmas)**2)
# print('Chi2 True = {}'.format(chi2_true))

# mymap2 = np.array(m.values)
# myresult2, myintercals2 = myH.give_intercals(m.values)

# subplot(2,3,1)
# plot(xpix, truey, label='True Sky')
# plot(xpix, mymap2, 'ro', label='reconstructed')
# xlabel('pixel')
# ylabel('sky')
# legend()

# subplot(2,3,2)
# plot(xpix, mymap2 - truey, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(mymap2 - truey)))
# plot(xpix, mymap - truey, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(mymap - truey)), alpha=0.5)
# xlabel('pixel')
# ylabel('sky')
# legend(fontsize=10)

# subplot(2,3,3)
# a = fit.myhist(mymap2 - truey, label='Minuit + Ana Residuals')
# a = fit.myhist(mymap - truey, label='Full Minuit Residuals')

# subplot(2,3,4)
# plot(intercal, label='True Intercals')
# plot(myintercals2, 'ro', label='reconstructed intercals')
# xlabel('Det')
# ylabel('Intercal')
# legend()

# subplot(2,3,5)
# plot(myintercals2-intercal, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(myintercals2-intercal)))
# plot(myintercals-intercal, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)), alpha=0.5)
# xlabel('Det')
# ylabel('Intercal')
# legend()

# subplot(2,3,6)
# a = fit.myhist(myintercals2-intercal, label='Minuit + Ana Residuals')
# a = fit.myhist(myintercals-intercal, label='Full Minuit Residuals')

# tight_layout()

# print()
# print('RMS Residuals')
# print('                   M+A                    M')
# print('              Map.      Inter.      Map.        Inter     ')
# print('            {0:5.3g}   {1:5.3g}    {2:5.3g}   {3:5.3g}'.format(np.std(mymap2 - truey), np.std(myintercals2-intercal), np.std(mymap - truey), np.std(myintercals-intercal)))

```

```{python}
# N = np.diag(sig**2)
# subplot(1,2,1)
# imshow(N)

# Ninv = np.diag(1./sig**2)
# subplot(1,2,2)
# imshow(Ninv)
```

```{python}
# d_noiseless = np.reshape(alltod_noiseless, (ndet, nsamples))[1:,:]
# d = np.reshape(alltod, (ndet, nsamples))[1:,:]
# D = np.reshape(alltod_intercal, (ndet, nsamples))[1:,:]
# myNinv = Ninv[1:,1:]

# print('d_noiseless: ', np.shape(d_noiseless))
# print('d: ', np.shape(d))
# print('D: ', np.shape(D))
# print('myNinv: ', np.shape(myNinv))
```

```{python}
# matrix = D @ (D.T @ myNinv)
# invmatrix = np.linalg.inv(matrix)
# print(np.shape(matrix))

# ic_noiseless = np.append(1, np.diag(invmatrix @ D @ (d_noiseless.T @ myNinv)))
# ic = np.append(1, np.diag(invmatrix @ D @ (d.T @ myNinv)))


# print(np.std(ic-intercal))
# print(np.std(ic_noiseless-intercal))
```

```{python}
# myH_noiseless = simulate_signal_intercal(xpix, ndet, nsamples, H, alltod_noiseless, 1./sig**2)
# TOD_INTERCAL, my_intercal_noiseless = myH_noiseless.give_intercals(truey)
# # print(my_intercal_noiseless)
# # plot(my_intercal_noiseless-intercal)

# print(np.ravel(TOD_INTERCAL)-alltod_intercal)
# print()

# print(np.shape(TOD_INTERCAL))
# print(np.shape(alltod_intercal))

# plot(np.ravel(TOD_INTERCAL), alltod_intercal)
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

### So let's go back to basic:
I need to be able to recover analytically my true intercalibrations in the case of noiseless data: from `alltod_noiseless`, I should be able to reconver `intercal`
- we have the `truey` vector which `(npix)` long

```{python}
np.random.seed(42)
print('npix', npix)
print('truey:', np.shape(truey))
```

- the H operator transforms a `npix` sky into a `ndet x nsamples` array:

```{python}
H = np.zeros((ndet, nsamples, npix))
for i in range(npix):
    H[:,:,i] = np.random.randint(0,2, size=(ndet, nsamples))
print('H', np.shape(H))
```

Operating `H` on the sky `truey` leads to a `(ndet x nsamples)` array containing our intercalibrated TOD:

```{python}
alltod_intercal = H @ truey
print('alltod_intercal', np.shape(alltod_intercal))
```

Intercalibrations are a `ndet` array called `intercal`:

```{python}
#intercal = np.append([1], (np.random.rand(ndet-1)+0.5))
print('intercal', np.shape(intercal))
print(intercal)
```

We can calculate the measured (non-intercalibrted) TOD brutally as:

```{python}
alltod_noiseless_brute = alltod_intercal.copy()
for k in range(ndet):
    alltod_noiseless_brute[k,:] *= intercal[k]
```

But we'd rather use broadcasting as:

```{python}
alltod_noiseless = (alltod_intercal.T * intercal).T
print('Sum of difference squared:', np.sum((alltod_noiseless-alltod_noiseless_brute)**2))
```

We now generate the noise which is distinct for each detector following a `ndet` vector called `sig`. We use broadcasting again: 

```{python}
sig = 1e-2*(np.random.rand(ndet)+0.5)
noise_sig = (np.random.randn(ndet, nsamples).T * sig).T
print('noise_sig', np.shape(noise_sig))
```

We can check that the RMS along the `nsamples`-axis of our noise foolows the `sig` array:

```{python}
print(np.std(noise_sig, axis=1)/sig)
```

So the final TOD is:

```{python}
alltod = alltod_noiseless + noise_sig
print('alltod', np.shape(alltod))
```

```{python}
print(np.std(alltod, axis=1))
```

### Now we should be able to recover the intercalibration from the true sky
$$ \hat{A} = \left(\hat{\vec{D}}^t N^{-1}\hat{\vec{D}}\right)^{-1} \hat{\vec{D}}^t N^{-1} \vec{d}$$


We remove the first detector for which the intercalibration will be set to 1

```{python}
d = alltod_noiseless.copy()
D = alltod_intercal.copy()
print('d: ', np.shape(d))
print('D: ', np.shape(D))

```

The noise covariance matrix is `Ndet x Ndet` and is diagonal given by `sig`

```{python}
N = np.diag(sig**2)
subplot(1,2,1)
imshow(N)

Ninv = np.diag(1./sig**2)
subplot(1,2,2)
imshow(Ninv)
```

```{python}
d_noiseless = alltod_noiseless[1:,:]
d = alltod[1:,:]
D = alltod_intercal[1:,:]
myNinv = Ninv[1:,1:]

print('d_noiseless: ', np.shape(d_noiseless))
print('d: ', np.shape(d))
print('D: ', np.shape(D))
print('myNinv: ', np.shape(myNinv))
```

```{python}
matrix = D @ (D.T @ myNinv)
invmatrix = np.linalg.inv(matrix)
print(np.shape(matrix))

ic_noiseless = np.append(1, np.diag(invmatrix @ D @ (d_noiseless.T @ myNinv)))
ic = np.append(1, np.diag(invmatrix @ D @ (d.T @ myNinv)))


print(np.std(ic-intercal))
print(np.std(ic_noiseless-intercal))
```

```{python}
subplot(1,2,1)
plot(ic)
plot(intercal)

subplot(1,2,2)
plot(ic-intercal)
```

```{python}
subplot(1,2,1)
imshow(matrix)
colorbar()

subplot(1,2,2)
imshow(invmatrix)
colorbar()
```

```{python}
imshow(D)
colorbar()
```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}
reload(fit)

class simulate_signal_intercal:
    def __init__(self, xpix, ndet, nsamples, H, d, w):
        self.xpix = xpix
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
        self.d = np.reshape(d, (ndet, nsamples))
        self.w = w
    def __call__(self, x, sky):
        D, intercal = self.give_intercals(sky)
        for k in range(self.ndet):
            D[k,:] *= intercal[k]
        return np.ravel(D)
    def give_intercals(self, sky):
        ### We remove the first detector from the fit as its intercalibration is forced to 1
        D = (np.reshape(np.dot(self.H, sky), (self.ndet, self.nsamples)))
        print('D', np.shape(D))
        myD = D[1:,:]
        print('myD', np.shape(myD))
        W = np.diag(self.w[1:])
        print('W', np.shape(W))
        matrix = myD.T @ W @ myD
        print('m', np.shape(matrix))
        print('m @ myD.T', np.shape(np.linalg.inv(matrix) @ myD.T))
        print('m @ myD.T @ W', np.shape(np.linalg.inv(matrix) @ myD.T @ W))
        print('m @ myD.T @ W @ self.d[1:,:]', np.shape(np.linalg.inv(matrix) @ myD.T @ W @ self.d[1:,:]))
        intercal_rec = np.append(1, np.diag((np.linalg.inv(matrix) @ myD.T @ W @ self.d[1:,:])))
        print('intercal_rec', np.shape(intercal_rec))
        stop
        return D, intercal_rec

sigmas = np.ones(len(alltod))
for k in range(ndet):
    sigmas[k*nsamples:(k+1)*nsamples] *= sig[k]

#### Fit
myH = simulate_signal_intercal(xpix, ndet, nsamples, H, alltod, 1./sig**2)
guess_sky = np.ones(len(xpix))
xxx = np.zeros(len(alltod))   # not used
data = fit.Data(xxx, alltod, sigmas, myH)
m, ch2, ndf = data.fit_minuit(guess_sky)
mytod_th = myH(0, m.values)
chi2_ana = np.sum( ((mytod_th-alltod)/sigmas)**2)




print('Minuit says : chi2={} ndf={}'.format(ch2, ndf))
print('But we know it forgets the {} variables we fit analytically, so it should say {}'.format(ndet-1, ndf-(ndet-1)))
print('============================')
print('My Chi2 = {}'.format(chi2_ana))
print('The number of unknowns is: {}'.format(npix + ndet -1))
print('The number of points is: {}'.format(len(alltod)))
print('The ndf={}'.format(len(alltod)-(npix+ndet-1)))
print('============================')
print('With True Sky')

mytod_true = myH(0, truey)
chi2_true = np.sum( ((mytod_true-alltod)/sigmas)**2)
print('Chi2 True = {}'.format(chi2_true))

mymap3 = np.array(m.values)
myresult3, myintercals3 = myH.give_intercals(m.values)
print('-------')
print(np.shape(myresult3))
print(np.shape(myintercals3))



stop

subplot(2,3,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap3, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,3,2)
plot(xpix, mymap3 - truey, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(mymap3 - truey)))
plot(xpix, mymap - truey, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(mymap - truey)), alpha=0.5)
xlabel('pixel')
ylabel('sky')
legend(fontsize=10)

subplot(2,3,3)
a = fit.myhist(mymap3 - truey, label='Minuit + Ana Residuals')
a = fit.myhist(mymap - truey, label='Full Minuit Residuals')

subplot(2,3,4)
plot(intercal, label='True Intercals')
plot(myintercals3, 'ro', label='reconstructed intercals')
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,5)
plot(myintercals3-intercal, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(myintercals3-intercal)))
plot(myintercals-intercal, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)), alpha=0.5)
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,6)
a = fit.myhist(myintercals3-intercal, label='Minuit + Ana Residuals')
a = fit.myhist(myintercals-intercal, label='Full Minuit Residuals')

tight_layout()

print()
print('RMS Residuals')
print('                   M+A                    M')
print('              Map.      Inter.      Map.        Inter     ')
print('            {0:5.3g}   {1:5.3g}    {2:5.3g}   {3:5.3g}'.format(np.std(mymap3 - truey), np.std(myintercals3-intercal), np.std(mymap - truey), np.std(myintercals-intercal)))

```

```{python}
debug
```

```{python}
print(np.shape(myresult2))
print(np.shape(myintercals2))

```

```{python}

```
