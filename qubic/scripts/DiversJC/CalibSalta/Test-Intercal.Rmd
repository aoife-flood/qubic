---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.14.0
  kernelspec:
    display_name: Python 3 (ipykernel)
    language: python
    name: python3
---

```{python}
# %config InlineBackend.figure_format='retina'
from IPython.display import display, HTML
display(HTML("<style>.container { width:95% !important; }</style>"))

import fitting as fit
from importlib import reload
import iminuit


rc('figure',figsize=(20,6))
rc('font',size=12)
```

```{python}
#### Simulate input true "sky"
npix = 50
xpix = np.linspace(0,1,npix)

x0 = 0.5
maxy = 1.
α = -maxy / (x0-x0**2)
β = - α
amp = 1.
w0 = 0.1
ph = 0.3

truey = α*xpix**2 + β*xpix + amp*np.sin(xpix/w0+2*np.pi * ph)

plot(xpix, truey, label='True Sky')
xlabel('pixel')
ylabel('sky')
legend()
###########

```

# Exact  "Map-making" solution

```{python}
###### Simulate observations with perfect intercalibrations
ndet = 50
nsamples = 100
sig = 1e-2


H = np.zeros((ndet*nsamples, npix))
for i in range(npix):
    H[:,i] = np.random.randint(0,2, size=nsamples*ndet)

###### Here we assume that all detectors see all pixels a few times and all at the same time
# nnn = nsamples // npix
# H = np.zeros((ndet*nsamples, npix))
# ### We want each pixel to be seen by all detectors
# for i in range(npix):
#     seenpix = np.zeros((ndet, nsamples))
#     for k in range(nnn): 
#         seenpix[:, k*npix+i] = 1
#         H[:,i] = np.ravel(seenpix)
#########################
    
alltod = np.dot(H, truey) + np.random.randn(ndet*nsamples)*sig 


#### Solve the linear problem
mymap = np.linalg.inv(H.T@H)@H.T@alltod

subplot(1,2,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(1,2,2)
plot(xpix, mymap - truey, label='Residuals σ={0:5.3g}'.format(np.std(mymap - truey)))
xlabel('pixel')
ylabel('sky')
legend()

tight_layout()
```

# Same problem resolution but with aconjugate gradient (Minuit)
=> Philosophically what we do with QUBIC...

```{python}


class simulate_signal:
    def __init__(self, xpix, ndet, nsamples, H):
        self.xpix = xpix
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
    def __call__(self, x, sky):
        alltod = np.dot(self.H, sky)
        return alltod


myH = simulate_signal(xpix, ndet, nsamples, H)


guess_sky = np.zeros(len(xpix)) 
xxx = np.zeros(len(alltod))   # not used
data = fit.Data(xxx, alltod, xxx*0+1, myH)

m, ch2, ndf = data.fit_minuit(guess_sky+1)

mymap = m.values

subplot(1,2,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(1,2,2)
plot(xpix, mymap - truey, label='Residuals σ={0:5.3g}'.format(np.std(mymap - truey)))
xlabel('pixel')
ylabel('sky')
legend()

tight_layout()
```

# Now let's put unknown intercalibrations and fit them alltogether with the sky - We also put a non uniform noise on the different detectors

```{python}
#np.random.seed(42)
###### Simulate observations including intercalibration
ndet = 50
nsamples = 100

###### Noise:
# Uniform noise
# sig = np.zeros(ndet) + 1e-2
# Variable noise across detectors
sig = 1e-2*np.random.rand(ndet)


H = np.zeros((ndet*nsamples, npix))
for i in range(npix):
    H[:,i] = np.random.randint(0,2, size=nsamples*ndet)
    
intercal = np.append([1], (np.random.rand(ndet-1)+0.5))
alltod_intercal = np.dot(H, truey)
alltod = alltod_intercal.copy()
alltod_noiseless = alltod_intercal.copy()
for k in range(ndet):
    alltod_noiseless[k*nsamples:(k+1)*nsamples] *= intercal[k]
    alltod[k*nsamples:(k+1)*nsamples] *= intercal[k]
    alltod[k*nsamples:(k+1)*nsamples] += np.random.randn(nsamples)*sig[k]
#########################

sigmas = np.ones(len(alltod))
for k in range(ndet):
    sigmas[k*nsamples:(k+1)*nsamples] *= sig[k]


    
chi2_noiseless = np.sum(((alltod-alltod_noiseless)/sigmas)**2)   
print('Chi2 Noiseless: ',chi2_noiseless)
```

# Here we fully sove with Minuit

```{python}
class simulate_signal_intercal:
    def __init__(self, xpix, ndet, nsamples, H):
        self.xpix = xpix
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
    def __call__(self, x, sky_and_intercal):
        sky = sky_and_intercal[:len(self.xpix)]
        intercal = sky_and_intercal[len(self.xpix):]
        alltod = np.dot(self.H, sky)
        for k in range(self.ndet):
            alltod[k*self.nsamples:(k+1)*self.nsamples] *= intercal[k]
        return alltod


myH = simulate_signal_intercal(xpix, ndet, nsamples, H)

guess_sky = np.append(np.zeros(len(xpix)), np.ones(ndet))

xxx = np.zeros(len(alltod))   # not used
data = fit.Data(xxx, alltod, sigmas, myH)
m, ch2, ndf = data.fit_minuit(guess_sky, fixpars = [len(xpix)])
mytod_th = myH(0, m.values)
chi2_ana = np.sum( ((mytod_th-alltod)/sigmas)**2)

print('Minuit says : chi2={} ndf={}'.format(ch2, ndf))
print('============================')
print('My Chi2 = {}'.format(chi2_ana))
print('The number of unknowns is: {}'.format(npix + ndet -1))
print('The number of points is: {}'.format(len(alltod)))
print('The ndf={}'.format(len(alltod)-(npix+ndet-1)))
print('============================')
print('With noiseless true TOD')
chi2_true = np.sum( ((alltod_noiseless-alltod)/sigmas)**2)
print('Chi2 True = {}'.format(chi2_true))


mymap = m.values[:len(xpix)]
myintercals = m.values[len(xpix):]


subplot(2,2,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,2,2)
plot(xpix, mymap - truey, label='Residuals σ={0:5.3g}'.format(np.std(mymap - truey)))
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,2,3)
plot(intercal, label='True Intercals')
plot(myintercals, 'ro', label='reconstructed intercals')
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,2,4)
plot(myintercals-intercal, label='Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)))
xlabel('Det')
ylabel('Intercal')
legend()

tight_layout()
```

# Next exercize:
We do not fit the intercalibrations with the conjugate gradient but we use the fact that they are linear with the data to fit them analytically at each step of the conjugate gradient.

We should get the same performance, but for now, we don't...


We have data from $n_d$ detectors that observe a sky $\vec{s}$ through an instrument modeled by the operator $H$. Each detector has its own intercalibration.

So the perfectly intercalibrated data writes:
    $$ \vec{D} = H\vec{s} + \vec{n}$$
And the maximum likelihood solution would be:
    $$\hat{\vec{s}} = \left(H^t N^{-1} H\right)^{-1} H^t N^{-1} \vec{D}$$
    
But in reality we measure $\vec{d}$ which is not intercalibrated:
$$\vec{d}=\vec{D} A$$ where A is unknown...

So we proceed with the "inverse problem" approach:
$$\vec{d}=\vec{D} A = H \vec{s} A+\vec{n}$$

We vary $A$ and $\vec{s}$ and minimize:
$$\chi^2(A,\vec{s}) = \left(H\vec{s}A-\vec{d}\right)^t N^{-1}\left(H\vec{s}A-\vec{d}\right)$$
the solution is obtained by solving:
$$\frac{d\chi^2}{dA^t} = 0 = \vec{s}^t H^t N^{-1} H \vec{s}A - \vec{s}^t H^t N^{-1}\vec{d}$$
$$\Rightarrow~~~~ A= \left(\vec{s}^t H^t N^{-1} H \vec{s}\right)^{-1} \vec{s}^t H^t N^{-1}\vec{d}$$

So, at each step of the conjugate gradient (at each call to Minuit), we will test a sky $\vec{s}_i$ that correpsonds to "test"-intercalibrated data $\vec{D}_i = H\vec{s}_i$. We will compute at each of those steps:
$$A_i = \left(\vec{D}_i^t N^{-1}\vec{D}_i\right) \vec{D}_i^t N^{-1} \vec{d}$$
which allows to compute the corresponding $\chi^2$ as:
$$ \chi^2 = \left(\vec{D}_i A_i-\vec{d}\right)^t N^{-1}\left(\vec{D}_i A_i -\vec{d}\right)$$
and we minimize it only with respect to $\vec{s}$.

Once we have converged on $\hat{\vec{s}}$, the intercalibrations will be obtained by:
$$ \hat{\vec{D}} = H\hat{\vec{s}}$$
and
$$ \hat{A} = \left(\hat{\vec{D}}^t N^{-1}\hat{\vec{D}}\right)^{-1} \hat{\vec{D}}^t N^{-1} \vec{d}$$


### In practice:
If $N$ is dense it is possibly a large problem...

- if $N\propto \mathbb{1}$ the problem is completely simplified and $N$ disappears:
    - $\vec{D}_i = H\vec{s}_i$
    - $A_i = \left(\vec{D}^t\vec{D}\right)^{-1}\vec{D}^t \vec{d}$
    - $\chi^2 = \| \vec{D}_i A_i -\vec{d}\|^2$
    
- If $N$ is diagonal: $N^{-1} = \vec{w}\mathbb{1}$
    - $\vec{D}_i = H\vec{s}_i$
    - $A_i = \left(\vec{D}^t\vec{w}\vec{D}\right)^{-1}\vec{D}^t \vec{w}\vec{d}$
    - $\chi^2 = \|\vec{\sqrt{w}}\cdot\left(\vec{D}_i A_i -\vec{d}\right)\|^2$


```{python}
reload(fit)

class simulate_signal_intercal:
    def __init__(self, xpix, ndet, nsamples, H, d, w):
        self.xpix = xpix
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
        self.d = np.reshape(d, (ndet, nsamples))
        self.w = w
    def __call__(self, x, sky):
        # get the intercalibrated TOD directly from the sky + the calculated intercalibrations
        D, intercal = self.give_intercals(sky)
        # apply the intercalibrations
        D = (D.T * intercal).T
        return np.ravel(D)
    def give_intercals(self, sky):
        ### We remove the first detector from the fit as its intercalibration is forced to 1
        D = (np.reshape(np.dot(self.H, sky), (self.ndet, self.nsamples)))
        myD = D[1:,:]
        w = self.w[1:]
        myw = np.diag(w)
        matrix = myD @ (myD.T @ myw)
        intercal_rec = np.append(1, np.diag(np.linalg.inv(matrix) @ (myD @ (self.d[1:,:].T @ myw))))
        return D, intercal_rec

sigmas = np.ones(len(alltod))
for k in range(ndet):
    sigmas[k*nsamples:(k+1)*nsamples] *= sig[k]

#### Fit
myH = simulate_signal_intercal(xpix, ndet, nsamples, H, alltod, 1./sig**2)
guess_sky = np.ones(len(xpix))
xxx = np.zeros(len(alltod))   # not used
data = fit.Data(xxx, alltod, sigmas, myH)
m, ch2, ndf = data.fit_minuit(guess_sky)
mytod_th = myH(0, m.values)
chi2_ana = np.sum( ((mytod_th-alltod)/sigmas)**2)



print('Minuit says : chi2={} ndf={}'.format(ch2, ndf))
print('But we know it forgets the {} variables we fit analytically, so it should say {}'.format(ndet-1, ndf-(ndet-1)))
print('============================')
print('My Chi2 = {}'.format(chi2_ana))
print('The number of unknowns is: {}'.format(npix + ndet -1))
print('The number of points is: {}'.format(len(alltod)))
print('The ndf={}'.format(len(alltod)-(npix+ndet-1)))
print('============================')
print('With noiseless true TOD')
chi2_true = np.sum( ((alltod_noiseless-alltod)/sigmas)**2)
print('Chi2 True = {}'.format(chi2_true))

mymap2 = np.array(m.values)
myresult2, myintercals2 = myH.give_intercals(m.values)

subplot(2,3,1)
plot(xpix, truey, label='True Sky')
plot(xpix, mymap2, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,3,2)
plot(xpix, mymap2 - truey, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(mymap2 - truey)))
plot(xpix, mymap - truey, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(mymap - truey)), alpha=0.5)
xlabel('pixel')
ylabel('sky')
legend(fontsize=10)

subplot(2,3,3)
a = fit.myhist(mymap2 - truey, label='Minuit + Ana Residuals')
a = fit.myhist(mymap - truey, label='Full Minuit Residuals')

subplot(2,3,4)
plot(intercal, label='True Intercals')
plot(myintercals2, 'ro', label='reconstructed intercals')
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,5)
plot(myintercals2-intercal, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(myintercals2-intercal)))
plot(myintercals-intercal, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)), alpha=0.5)
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,6)
a = fit.myhist(myintercals2-intercal, label='Minuit + Ana Residuals')
a = fit.myhist(myintercals-intercal, label='Full Minuit Residuals')

tight_layout()

print()
print('RMS Residuals')
print('                   M+A                    M')
print('              Map.      Inter.      Map.        Inter     ')
print('            {0:5.3g}   {1:5.3g}    {2:5.3g}   {3:5.3g}'.format(np.std(mymap2 - truey), np.std(myintercals2-intercal), np.std(mymap - truey), np.std(myintercals-intercal)))

```

```{python}
chi2_noiseless = np.sum( ((alltod_noiseless-alltod)/sigmas)**2)
print('Chi2 with noiseless',chi2_noiseless)
print()

##### Intercalibrated TOD and intercalibration using the True Sky
myD_true, myintercals_true = myH.give_intercals(truey)
##### Or using the fitted one
myD_fit, myintercals_fit = myH.give_intercals(m.values)

print('Intercalibrated TOD difference')
print('Init - myH(true) (=> should be 0)  RMS=',np.std(np.reshape(alltod_intercal, (ndet, nsamples)) - myD_true))
print('Init - myH(fit)   RMS=',np.std(np.reshape(alltod_intercal, (ndet, nsamples)) - myD_fit))

print()
print('Intercal differences')
print('Init - myH(true)   RMS=',np.std(myintercals_true-intercal))
print('Init - myH(fit)   RMS=',np.std(myintercals_fit-intercal))
plot(myintercals_true-intercal)
plot(myintercals_fit-intercal)

print('These two are very similar because even when you have the perfectly right sky, when calculating analytically the intercals')
print('you calulate it against the noisy TOD => extra noise')
```

- The extra noise we see on the intercalibration is also present when we calculate the intercalibrations with the true sky as an input. This comes from the fact that the measured TOD is involved in the intercal expression (last term). If this term is replaced by the noiseless TOD then the=is extra noise vanishes.
- So I suspect that my problem is due to a bad implementation of the w weighting. Maybe just muliplying as I do is not valid.


# Alternative method: following [Stompor et al., 2009]
We use the method proposed in [Stompor et al., 2009] (https://arxiv.org/pdf/0804.2645.pdf) for maximum-likelihood estimation of component separation. Here, intercalibrations are the analogous of the spectral behaviour of the astrophysical components. 

The method is the following:
We have data from $n_d$ detectors that observe a sky $\vec{s}$ through an instrument modeled by the operator $H$. Each detector has its own intercalibration $A$.

The perfectly intercalibrated data writes:
    $$ \vec{D} = H\vec{s} + \vec{n}$$
    
But in reality we measure $\vec{d}$ which is not intercalibrated:
$\vec{d}=A\vec{D} $ where A is unknown...

So we have:
    $$ 
    \begin{eqnarray}
        \vec{d} &=& A H\vec{s} + \vec{n} \\
                &=& B \vec{s} + \vec{N}
    \end{eqnarray}
    $$

The LogLikelihood writes:
    $$
    \begin{eqnarray}
        \chi^2(A, \vec{s}) = -2 \ln \mathcal{L}(A, \vec{s}) &=& \left(\vec{d}-AH\vec{s}\right)^t N^{-1}\left(\vec{d}-AH\vec{s}\right)\\
        &=& \left(\vec{d}-B\vec{s}\right)^t N^{-1}\left(\vec{d}-B\vec{s}\right)
    \end{eqnarray}
    $$

With formal solution for the sky $\vec{s}$:
    $$\hat{\vec{s}} = \left(B^t N^{-1} B\right)^{-1} B^t N^{-1} \vec{D}$$

Now the trick is to reinject this solution into the LogLikelihood in order to have a Likelihood that only depends upon $A$ (through $B$):
    $$
    \begin{eqnarray}
        \chi^2(A) = -2 \ln \mathcal{L}(A) &=& \left(\vec{d}-B\hat{\vec{s}}\right)^t N^{-1}\left(\vec{d}-B\hat{\vec{s}}\right) \\
        &=& ... \\
        &=& \vec{d}^t N^{-1}\vec{d} - \left(B^t N^{-1} \vec{d}\right)^t \left(B^t N^{-1} B\right)^{-1} \left(B^t N^{-1} \vec{d}\right) \\
        &=& \vec{d}^t N^{-1}\vec{d} - \left(H^t A^t N^{-1} \vec{d}\right)^t \left(H^t A^t N^{-1} AH\right)^{-1} \left(H^t A^t N^{-1} \vec{d}\right) 
    \end{eqnarray}
    $$
which, as expectd only depends upon the intercalibrations $A$.

We therefore minimize this $\chi^2$ using `Minuit` and once we have the bets-fit $\hat{A}$, we can calculate the sky through:
$$ \hat{\vec{s}} = \left(H^t \hat{A}^t N^{-1} \hat{A}H\right)^{-1} \left(H^t \hat{A}^t N^{-1} \vec{d}\right) $$

```{python}
reload(fit)
class RidgeChi2:
    """
    Ridge Chi2
    """
    
    errordef = iminuit.Minuit.LEAST_SQUARES # for Minuit to compute errors correctly

    def __init__(self, x, y, err, model):
        self.model = model  # model predicts y for given x
        self.x = np.asarray(x)
        self.y = np.asarray(y)
        self.err = np.asarray(err)
        self.w = 1./self.err**2
        self.dNid = self.y.T * self.w @ self.y   # d^t N^{-1} d

    def __call__(self, *par):  
        B = self.model(self.x, *par)                  # B = A.H 
        BtNiB = B.T * self.w @ B                      # B^t N^{-1} B as noise is uncorrelated across detectors
        invBtNiB = np.linalg.inv(BtNiB)               # (B^t N^{-1} B)^{-1}
        BtNid = B.T * self.w @ self.y                 # (B^t N^{-1} d)
        ch2 = self.dNid - BtNid.T @ invBtNiB @ BtNid  # the chi2
        return ch2

    @property
    def ndata(self):
        return len(self.x)

class giveB:
    def __init__(self, H, ndet, nsamples):
        self.ndet = ndet
        self.nsamples = nsamples
        self.H = H
    
    def __call__(self, x, intercals):
        return (np.repeat(intercals, self.nsamples).T * H.T).T

    
sigmas = np.ones(len(alltod))
for k in range(ndet):
    sigmas[k*nsamples:(k+1)*nsamples] *= sig[k]

#### Fit
myB = giveB(H, ndet, nsamples)
guess_intercal = np.ones(ndet)

xxx = np.zeros(len(alltod))   # not used
rc2 = RidgeChi2(xxx, alltod, sigmas, myB)

data = fit.Data(xxx, alltod, sigmas, myB)
m, ch2, ndf = data.fit_minuit(guess_sky, minimizer=RidgeChi2, fixpars=[0])

### Now get the sky
bestB = myB(0, m.values)
bestSky = (np.linalg.inv(bestB.T * 1./sigmas**2 @ bestB) @ bestB.T * 1./sigmas**2 @ alltod) 

print('Minuit valid fit:', m.valid)
```

```{python}
subplot(2,3,1)
plot(xpix, truey, label='True Sky')
plot(xpix, bestSky, 'ro', label='reconstructed')
xlabel('pixel')
ylabel('sky')
legend()

subplot(2,3,2)
plot(xpix, mymap2 - truey, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(mymap2 - truey)))
plot(xpix, mymap - truey, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(mymap - truey)), alpha=0.5)
plot(xpix, bestSky - truey, label='Ridhe Residuals σ={0:5.3g}'.format(np.std(mymap - truey)), alpha=0.5)
xlabel('pixel')
ylabel('sky')
legend(fontsize=10)

subplot(2,3,3)
a = fit.myhist(mymap2 - truey, label='Minuit + Ana Residuals')
a = fit.myhist(mymap - truey, label='Full Minuit Residuals')
a = fit.myhist(bestSky - truey, label='Ridge Residuals')

subplot(2,3,4)
plot(intercal, label='True Intercals')
plot(myintercals2, 'ro', label='reconstructed intercals')
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,5)
plot(myintercals2-intercal, label='Minuit + Ana Residuals σ={0:5.3g}'.format(np.std(myintercals2-intercal)))
plot(myintercals-intercal, label='Full Minuit Residuals σ={0:5.3g}'.format(np.std(myintercals-intercal)), alpha=0.5)
plot(m.values-intercal, label='Ridge Residuals σ={0:5.3g}'.format(np.std(m.values-intercal)), alpha=0.5)
xlabel('Det')
ylabel('Intercal')
legend()

subplot(2,3,6)
a = fit.myhist(myintercals2-intercal, label='Minuit + Ana Residuals')
a = fit.myhist(myintercals-intercal, label='Full Minuit Residuals')
a = fit.myhist(m.values-intercal, label='Ridge Residuals')

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```
