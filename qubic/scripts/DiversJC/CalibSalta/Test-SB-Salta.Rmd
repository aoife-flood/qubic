---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.4.1
  kernelspec:
    display_name: Python 3
    language: python
    name: python3
---

```{python}
from IPython.display import set_matplotlib_formats
set_matplotlib_formats('retina')
from IPython.core.display import display, HTML
display(HTML("<style>.container { width:95% !important; }</style>"))

rc('figure',figsize=(16,8))
rc('font',size=12)

from scipy.signal import medfilt
from scipy.interpolate import interp1d

from qubicpack.qubicfp import qubicfp
from qubic import fibtools as ft

from importlib import reload
import healpy as hp

```

# Trying with QUBIC data from Salta

We use a Synthesized Beam scanning performed on April 16th 2022 in Salta (CalSrc at 140 GHz): 
`2022-04-16_12.37.59__ScanMap_Speed_VE14_FastNoMod`

Or alternatively, a scan a 170 GHz on April 14th:
`2022-04-14_13.17.33__ScanMap_Speed_VE14_FastNoMod`

```{python}
# mydatadir = '/Users/hamilton/Qubic/Calib-TD/'
# thedate = '2022-04-16'
# thedata = '2022-04-16_12.37.59__ScanMap_Speed_VE14_FastNoMod'

mydatadir = '/Users/hamilton/Qubic/Calib-TD/'
thedate = '2022-04-14'
thedata = '2022-04-14_13.17.33__ScanMap_Speed_VE14_FastNoMod'



filename = mydatadir + '/' + thedate + '/' + thedata

### Read data
a = qubicfp()
a.read_qubicstudio_dataset(filename)

tt, tod = a.tod()

az = a.azimuth()
el = a.elevation()
thk = a.timeaxis(datatype='hk')
```

### First just a glimpse at the data

```{python}
TESnum = 33
tod = tod[TESnum-1,:]
del(a)

### We remove tt[0]
tinit = tt[0]
tt -= tinit
thk -= tinit

subplot(2,2,1)
plot(tt, tod)
xlabel('t')
ylabel('TOD')

subplot(2,2,2)
plot(az, el)
xlabel('az')
ylabel('el')

subplot(2,2,3)
plot(thk, az)
xlabel('t')
ylabel('az')

subplot(2,2,4)
plot(thk, el)
xlabel('t')
ylabel('el')

```

### Identifying scans
For the mapmaking and for many purposes, it will be very useeful to identify each scan:
- a numbering for each back & forth scan
- a region to remove at the end of each scan (bad data due to FLL reset, slowingg down of the moiunt, possibly HWP rotation
- is the scan back or forth ?

The function below is intended as a first version of this.

```{python}
def identify_scans(thk, az, el, tt=None, median_size=101, thr_speedmin=0.1, doplot=False, plotrange=[0,1000]):
    """
    This function identifies and assign numbers the various regions of a back-and-forth scanning using the housepkeeping time, az, el
        - a numbering for each back & forth scan
        - a region to remove at the end of each scan (bad data due to FLL reset, slowingg down of the moiunt, possibly HWP rotation
        - is the scan back or forth ?
    It optionnaly iinterpolate this information to the TOD sampling iif provided.

    Parameters
    ----------
    input
    thk : np.array()
            time samples (seconds) for az and el at the housekeeeping sampling rate
    az : np.array()
            azimuth in degrees at the housekeeping sampling rate
    el : np.array()
            elevation in degrees at the housekeeping sampling rate
    tt : Optional : np.array()
            None buy default, if not None:
            time samples (seconds) at the TOD sampling rate
            Then. the output will also containe az,el and scantype interpolated at TOD sampling rate
    thr_speedmin : Optional : float
            Threshold for angular velocity to be considered as slow
    doplot : [Optional] : Boolean
            If True displays some useeful plot
    output : 
    scantype_hk: np.array(int)
            type of scan for each sample at housekeeping sampling rate:
            * 0 = speed to slow - Bad data
            * n = scanning towards positive azimuth
            * -n = scanning towards negative azimuth
            where n is the scan number (starting at 1)
    azt : [optional] np.array()
            azimuth (degrees) at the TOD sampling rate
    elt : [optional] np.array()
            elevation (degrees) at the TOD sampling rate
    scantype : [optiona] np.array()
            same as scantype_hk, but interpolated at TOD sampling rate
    """
    
    ### Sampling for HK data
    timesample = np.median(thk[1:]-thk[:-1])
    ### angular velocity 
    medaz_dt = medfilt(np.gradient(az, timesample), median_size)
    ### Identify regions of change
    # Low velocity -> Bad
    c0 = np.abs(medaz_dt) < thr_speedmin
    # Positive velicity => Good
    cpos = (~c0) * (medaz_dt > 0)
    # Negative velocity => Good
    cneg = (~c0) * (medaz_dt < 0)
    
    ### Scan identification at HK sampling
    scantype_hk = np.zeros(len(thk), dtype='int')-10
    scantype_hk[c0] =0
    scantype_hk[cpos] = 1
    scantype_hk[cneg] = -1
    # check that we have them all
    count_them = np.sum(scantype_hk==0) + np.sum(scantype_hk==-1) + np.sum(scantype_hk==1)
    if count_them != len(scantype_hk):
        print('Identify_scans: Bad Scan counting at HK sampling level - Error')
        stop
    
    ### Now give a number to each back and forth scan
    num = 0
    previous = 0
    for i in range(len(scantype_hk)):
        if scantype_hk[i] == 0:
            previous = 0
        else:
            if (previous == 0) & (scantype_hk[i] > 0):
                # we have a change
                num += 1
            previous = 1
            scantype_hk[i] *= num
            
    dead_time = np.sum(c0) / len(thk)
    
    if doplot:
        ### Some plotting
        subplot(2,2,1)
        title('Angular Velocity Vs. Azimuth - Dead time = {0:4.1f}%'.format(dead_time*100))
        plot(az, medaz_dt)
        plot(az[c0], medaz_dt[c0], 'ro', label='Slow speed')
        plot(az[cpos], medaz_dt[cpos], '.', label='Scan +')
        plot(az[cneg], medaz_dt[cneg], '.', label='Scan -')
        xlabel('Azimuth [deg]')
        ylabel('Ang. velocity [deg/s]')
        legend(loc='upper left')

        subplot(2,2,2)
        title('Angular Velocity Vs. time - Dead time = {0:4.1f}%'.format(dead_time*100))
        plot(thk, medaz_dt)
        plot(thk[c0], medaz_dt[c0], 'ro', label='speed=0')
        plot(thk[cpos], medaz_dt[cpos], '.', label='Scan +')
        plot(thk[cneg], medaz_dt[cneg], '.', label='Scan -')
        legend(loc='upper left')
        xlabel('Time [s]')
        ylabel('Ang. velocity [deg/s]')
        xlim(plotrange[0],plotrange[1])

        subplot(2,3,4)
        title('Azimuth Vs. time - Dead time = {0:4.1f}%'.format(dead_time*100))
        plot(thk, az)
        plot(thk[c0], az[c0], 'ro', label='speed=0')
        plot(thk[cpos], az[cpos], '.', label='Scan +')
        plot(thk[cneg], az[cneg], '.', label='Scan -')
        legend(loc='upper left')
        xlabel('Time [s]')
        ylabel('Azimuth [deg]')
        xlim(plotrange[0],plotrange[1])

        subplot(2,3,5)
        title('Elevation Vs. time - Dead time = {0:4.1f}%'.format(dead_time*100))
        plot(thk, el)
        plot(thk[c0], el[c0], 'ro', label='speed=0')
        plot(thk[cpos], el[cpos], '.', label='Scan +')
        plot(thk[cneg], el[cneg], '.', label='Scan -')
        legend(loc='lower left')
        xlabel('Time [s]')
        ylabel('Elevtion [deg]')
        xlim(plotrange[0],plotrange[1])
        elvals = el[(thk > plotrange[0]) & (thk < plotrange[1])]
        deltael = np.max(elvals) - np.min(elvals)
        ylim(np.min(elvals) - deltael/5, np.max(elvals) + deltael/5)
        
        allnums = np.unique(np.abs(scantype_hk))
        for n in allnums[allnums > 0]:
            ok = np.abs(scantype_hk) == n
            xx = np.mean(thk[ok]) 
            yy = np.mean(el[ok])
            if (xx > plotrange[0])  & (xx < plotrange[1]):
                text(xx, yy+deltael/20, str(n))
                
        subplot(2,3,6)
        title('Elevation Vs. time - Dead time = {0:4.1f}%'.format(dead_time*100))
        thecol = (arange(len(allnums))*256/(len(allnums)-1)).astype(int)
        for i in range(len(allnums)):
            ok = np.abs(scantype_hk) == allnums[i]
            plot(az[ok], el[ok], color=get_cmap(rcParams['image.cmap'])(thecol[i]))
        ylim(np.min(el), np.max(el))
        xlabel('Azimuth [deg]')
        ylabel('Elevtion [deg]')
        scatter(-allnums*0, -allnums*0-10,c=allnums)
        aa=colorbar()
        aa.ax.set_ylabel('Scan number')        

        tight_layout()

    if tt is not None:
        ### We propagate these at TOD sampling rate  (this is an "step interpolation": we do not want intermediatee values")
        scantype = interp1d(thk, scantype_hk, kind='previous', fill_value='extrapolate')(tt)
        scantype = scantype.astype(int)
        count_them = np.sum(scantype==0) + np.sum(scantype<=-1) + np.sum(scantype>=1)
        if count_them != len(scantype):
            print('Bad Scan counting at data sampling level - Error')
            stop
        ### Interpolate azimuth and elevation to TOD sampling
        azt = np.interp(tt, thk, az)
        elt = np.interp(tt, thk, el)
        ### Return evereything
        return scantype_hk, azt, elt, scantype
    else:
        ### Return scantype at HK sampling only
        return scantype_hk
        
```

```{python}
rc('figure',figsize=(20,10))
rc('font',size=12)

### Identify scan types and numbers
scantype_hk, azt, elt, scantype = identify_scans(thk, az, el, tt=tt, doplot=True, plotrange=[0,2000], thr_speedmin=0.1)
```

```{python}
def healpix_map(azt, elt, tod, nside=128, countcut=0, unseen_val=hp.UNSEEN):
    ips = hp.ang2pix(nside, azt, elt, lonlat=True)
    mymap = np.zeros(12*nside**2)
    mapcount = np.zeros(12*nside**2)
    for i in range(len(azt)):
        mymap[ips[i]] += tod[i]
        mapcount[ips[i]] += 1
    unseen = mapcount <= countcut
    mymap[unseen] = unseen_val
    mapcount[unseen] = unseen_val
    mymap[~unseen] = mymap[~unseen] / mapcount[~unseen]
    return mymap, mapcount
```

```{python}
def get_mode(y, nbinsmin=51):
    mm, ss = ft.meancut(y, 4)
    hh = np.histogram(y, bins=int(np.min([len(y) / 30, nbinsmin])), range=[mm - 5 * ss, mm + 5 * ss])
    idmax = np.argmax(hh[0])
    mymode = 0.5 * (hh[1][idmax + 1] + hh[1][idmax])
    return mymode

```

### Simple map-making: just removing median from TOD

```{python}
anatype = 'Raw'

mytod = -tod - np.median(-tod[scantype != 0])
nside = 220
mapsb, mapcount = healpix_map(azt[scantype != 0], elt[scantype != 0], mytod[scantype != 0], nside=nside)
mapsb_pos, _ = healpix_map(azt[scantype > 0], elt[scantype > 0], mytod[scantype > 0], nside=nside)
mapsb_neg, _ = healpix_map(azt[scantype < 0], elt[scantype < 0], mytod[scantype < 0], nside=nside)
```

```{python}
unseen = (mapsb == hp.UNSEEN) | (mapsb_pos == hp.UNSEEN) | (mapsb_neg == hp.UNSEEN)

### Average of back and Forth
mapav = (mapsb_pos + mapsb_neg)/2
mapav[unseen] = hp.UNSEEN

### Difference of back and Forth
mapdiff = (mapsb_pos - mapsb_neg)
mapdiff[unseen] = hp.UNSEEN

### Difference of All and Av
mapdiff2 = (mapav - mapsb)
mapdiff2[unseen] = hp.UNSEEN

nlo = 3
nhi = 3
reso = 12
mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=-nlo*ss, max=nhi*ss)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=-nlo*ss, max=nhi*ss)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=-nlo*ss, max=nhi*ss)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=-nlo*ss, max=nhi*ss)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=-nlo*ssd, max=nlo*ssd)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=-nlo*ssd, max=nlo*ssd)


figure()
mini = -np.max(mapsb[~unseen])/10
maxi = np.max(mapsb[~unseen])*0.8

mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=mini, max=maxi)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=mini, max=maxi)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=mini, max=maxi)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=mini, max=maxi)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=mini, max=maxi)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=mini, max=maxi)

```

There are obvious issues:
1. significant elevation stripes in the maps: 
     - we need to equalize the average of each back & forth scan offset
2. a clear effect towards the right of the map: likely some "ground pickup" as we see it with the same pattern in the back and forth scans and absent in the subtraction of both.
    - we need to filter the signal in order to remove this or to measure a pattern in azimuth, common to all elevations.
    - It could also be seen with details in thee "no source" scans.
3. Synthesized beeam appears displaced between the back and forth scans:
    - we need to account for time constants
    - a shift in the timestamps has been identified beetween the mount az,el and the data... this is likely the main effect.


### Destriping scan by scan
Probably not good enough and will not help for "ground pickup" effect, but very easy to implement. We will just remove a clipped mean or median or the mode from each back and forth scan.

One can play with those options below (and try others), but for now the median leaves some features around the bright peaks and the modee seems unstable. We'll start with the clipped mean.

```{python}
def remove_offset_scan(mytod, scantype, method='meancut', apply_to_bad = True):
    ### We remove offsets for each good scan but we also need to remove a coomparable offset for the scantype==0 reggiions in order to keep coninuity 
    ### This si donee by apply_to_bad=True
    
    indices = np.arange(len(mytod))
    last_index = 0
    myoffsetn = 0
    myoffsetp = 0
    donefirst = 0
    
    nscans = np.max(np.abs(scantype))
    for n in range(1, nscans+1):
        # scan +
        ok = scantype == n
        if method == 'meancut':
            myoffsetp, _ = ft.meancut(mytod[ok], 3)
        elif method == 'median':
            myoffsetp = np.median(mytod[ok])
        elif method == 'mode':
            myoffsetp = get_mode(mytod[ok])
        else:
            break
        mytod[ok] -= myoffsetp        
        if apply_to_bad:
            first_index = np.min(indices[ok])
            if (n==1) & (donefirst==0): myoffsetn = myoffsetp ### deal with first region
            vals_offsets = myoffsetn + np.linspace(0,1, first_index-last_index-1)*(myoffsetp-myoffsetn)
            mytod[last_index+1:first_index] -= vals_offsets
            last_index = np.max(indices[ok])
            donefirst = 1
        
        
        # scan -
        ok = scantype == (-n)
        if method == 'meancut':
            myoffsetn, _ = ft.meancut(mytod[ok], 3)
        elif method == 'median':
            myoffsetn = np.median(mytod[ok])
        elif method == 'mode':
            myoffsetn = get_mode(mytod[ok])
        else:
            break
        mytod[ok] -= myoffsetn
        if apply_to_bad:
            first_index = np.min(indices[ok])
            if (n==1) & (donefirst==0): myoffsetp = myoffsetn ### deal with first region
            vals_offsets = myoffsetp + np.linspace(0,1, first_index-last_index-1)*(myoffsetn-myoffsetp)
            mytod[last_index+1:first_index] -= vals_offsets
            last_index = np.max(indices[ok])
            donefirst = 1
    
    return mytod


```

```{python}
anatype = 'Az Destriped'
nscans = np.max(np.abs(scantype))
mytod = -tod.copy()
mytod = remove_offset_scan(mytod, scantype, method='meancut')

plot(tt[scantype>0], mytod[scantype>0], '.', label='Scan +')
plot(tt[scantype<0], mytod[scantype<0], '.', label='Scan -')
plot(tt[scantype==0], mytod[scantype==0], '.', label='Bad')
xlim(0,1000)
ylim(-30000, 30000)
legend()
show()

mapsb, mapcount = healpix_map(azt[scantype != 0], elt[scantype != 0], mytod[scantype != 0], nside=nside)
mapsb_pos, _ = healpix_map(azt[scantype > 0], elt[scantype > 0], mytod[scantype > 0], nside=nside)
mapsb_neg, _ = healpix_map(azt[scantype < 0], elt[scantype < 0], mytod[scantype < 0], nside=nside)
    
```

```{python}
unseen = (mapsb == hp.UNSEEN) | (mapsb_pos == hp.UNSEEN) | (mapsb_neg == hp.UNSEEN)

### Average of back and Forth
mapav = (mapsb_pos + mapsb_neg)/2
mapav[unseen] = hp.UNSEEN

### Difference of back and Forth
mapdiff = (mapsb_pos - mapsb_neg)
mapdiff[unseen] = hp.UNSEEN

### Difference of All and Av
mapdiff2 = (mapav - mapsb)
mapdiff2[unseen] = hp.UNSEEN

nlo = 3
nhi = 3
reso = 12
mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=-nlo*ss, max=nhi*ss)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=-nlo*ss, max=nhi*ss)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=-nlo*ss, max=nhi*ss)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=-nlo*ss, max=nhi*ss)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=-nlo*ssd, max=nlo*ssd)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=-nlo*ssd, max=nlo*ssd)


figure()
mini = -np.max(mapsb[~unseen])/10
maxi = np.max(mapsb[~unseen])*0.8

mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=mini, max=maxi)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=mini, max=maxi)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=mini, max=maxi)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=mini, max=maxi)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=mini, max=maxi)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=mini, max=maxi)

```

As expected, it does not affect the ground pickup, but does a good job equalizing scans. We can try to remove a pattern in azimuth, common to all elevations.

(some striping seems still visible and is likely to be due to some 1/f noise - not constant within a scan - that will be reemoved with filtering later on).

### Lets build the "azimuth pattern":
- first we make a profile of the data as a function of azimuth, using the "mode" method. This meeans than in each azimuth bin, the program returns thee mode (maxiimum of thee distribution) of the TOD value for all elevations in this bin. Using the mode is quite powerful for neglecting the contribution from the bright signal peaks.
- then one fits this law with a degree 2 polynomial
- We see below that the profile is slightly different for positive and negative scans, so we do it separately.

```{python}
anatype = 'Az Corr removed'

mytod = -tod.copy()

# Remove offsets first usingg median (here we just want to have all scans at the same leveel before decorrelating from azimuth)
mytod = remove_offset_scan(mytod, scantype, method='median')

### Profiling in Azimuth
okall = np.abs(scantype) > 0 
okpos = scantype > 0 
okneg = scantype < 0 
oks = [okpos, okneg]
oks_names = ['+ scans', '- scans']
polys = []
for i in range(len(oks)):
    ok = oks[i]
    minaz = np.min(azt[ok])
    maxaz = np.max(azt[ok])
    xc, yc, dx, dy, _ = ft.profile(azt[ok], mytod[ok], rng=[minaz, maxaz], nbins=25, mode=True, dispersion=True, plot=False)
    xlabel('Azimuth [deg]')
    ylabel('Mode of TOD')
    z = polyfit(xc, yc, 2, w=1./dy)
    p = np.poly1d(z)
    polys.append(p)
    xaz = np.linspace(minaz, maxaz, 100)
    pl = errorbar(xc, yc, yerr=dy, xerr=dx, fmt='o')
    plot(xaz, p(xaz), label=oks_names[i], color=pl[0].get_color())
legend()
show()

### Removing the azimuthal effect
ok = scantype >= 0
mytod[ok] -= polys[0](azt[ok])
ok = scantype < 0
mytod[ok] -= polys[1](azt[ok])
    
# remove offsets again but this time with mode method as it appears to be less affected 
# by the presence of the peaks (no underestimation of the offset resultingg is shadow around the peaks)
mytod = remove_offset_scan(mytod, scantype, method='mode')

figure()
plot(tt[scantype>0], mytod[scantype>0], '.', label='Scan +')
plot(tt[scantype<0], mytod[scantype<0], '.', label='Scan +')
plot(tt[scantype==0], mytod[scantype==0], '.', label='Bad')
xlim(0,1000)
ylim(-30000, 30000)
legend()
show()


### Then make the maps
mapsb, mapcount = healpix_map(azt[scantype != 0], elt[scantype != 0], mytod[scantype != 0], nside=nside)
mapsb_pos, _ = healpix_map(azt[scantype > 0], elt[scantype > 0], mytod[scantype > 0], nside=nside)
mapsb_neg, _ = healpix_map(azt[scantype < 0], elt[scantype < 0], mytod[scantype < 0], nside=nside)
```

```{python}
unseen = (mapsb == hp.UNSEEN) | (mapsb_pos == hp.UNSEEN) | (mapsb_neg == hp.UNSEEN)

### Average of back and Forth
mapav = (mapsb_pos + mapsb_neg)/2
mapav[unseen] = hp.UNSEEN

### Difference of back and Forth
mapdiff = (mapsb_pos - mapsb_neg)
mapdiff[unseen] = hp.UNSEEN

### Difference of All and Av
mapdiff2 = (mapav - mapsb)
mapdiff2[unseen] = hp.UNSEEN

nlo = 3
nhi = 3
reso = 12
mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=-nlo*ss, max=nhi*ss)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=-nlo*ss, max=nhi*ss)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=-nlo*ss, max=nhi*ss)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=-nlo*ss, max=nhi*ss)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=-nlo*ssd, max=nlo*ssd)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=-nlo*ssd, max=nlo*ssd)


figure()
mini = -np.max(mapsb[~unseen])/10
maxi = np.max(mapsb[~unseen])*0.8

mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=mini, max=maxi)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=mini, max=maxi)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=mini, max=maxi)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=mini, max=maxi)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=mini, max=maxi)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=mini, max=maxi)

```

So one can see significant improvement: RMS of the background reduces from ~1.3e4 to 2.8e3.

However, the simplistic "Azimuth pattern" we fitted now appears to be insufficient. It seems that it also evolves with elevation... so we could measure it by elevation bins and get something better.
So there is still significant room for improvement.

We can also test filtering, but we'll have to avoid signal harmonics, and the "Az/el" bacckground pattern will also be ein those harmonics. Also for this wee'll need to fill the `scantype==0` regions with a constrained realization of noise in order to avoid FFT bouncing. This will be donee in a second time.


### Improving on azimuth/elevation background pattern
There are various ways for investigating this (and what I discuss here is surely not exhaustive):
- Trying to avoid signal with thiis TES and see how this changes with elevation.
- Use a dataset where the calibration source is off and cheeck how the pattern changes from one TES to another (important as it might give us some information on the optical or magnetic origin of this effect).
- With a single dataset we could also use multiple TES and make some median in order to avoid the signal as it will not be present on all TES at the same az/el...

For now, let's try the simplest approach: using a single TES.

```{python}
def get_chunks(mytod, scantype, value):
    ### returns chunks corresponding to a given value
    current_chunk = []
    chunk_idx = []
    inchunk = 0
    chunknum = 0
    for i in range(len(scantype)):
        if scantype[i]==value:
            inchunk = 1
            current_chunk.append(i)
        else:
            if inchunk == 1:
                chunknum += 1
                chunk_idx.append([current_chunk[0], current_chunk[len(current_chunk)-1]])
                current_chunk = []
                inchunk = 0
    if inchunk == 1:
        chunk_idx.append([current_chunk[0], current_chunk[len(current_chunk)-1]])
    return chunk_idx


def linear_rescale_chunks(mytod, chunks, sz=1000):
    for i in range(len(chunks)):
        thechunk = chunks[i]
        chunklen = thechunk[1] - thechunk[0]+1
        if thechunk[0] == 0:
            # this is the starting index => just the average
            vals = np.zeros(chunklen) + np.median(mytod[thechunk[1]+1: thechunk[1]+sz]) + np.median(mytod[thechunk[0]:thechunk[1]])
            mytod[thechunk[0]:thechunk[1]+1] -= vals
        elif thechunk[1]==(len(mytod)-1):
            # this is the last one => just the average
            vals = np.zeros(chunklen) + np.median(mytod[thechunk[0]-1-sz: thechunk[0]-1]) + np.median(mytod[thechunk[0]:thechunk[1]])
            mytod[thechunk[0]:thechunk[1]+1] -= vals
        else:
            left = np.median(mytod[thechunk[0]-1-sz: thechunk[0]-1])
            right = np.median(mytod[thechunk[1]+1: thechunk[1]+sz])
            vals = left + np.linspace(0,1, chunklen)*(right-left)
            mytod[thechunk[0]:thechunk[1]+1] -= np.median(mytod[thechunk[0]:thechunk[1]+1]) - vals
            
    return mytod
```

```{python}
anatype = 'Az/El Corr removed'

### Destriping for each scan with clipped mean
nscans = np.max(np.abs(scantype))
mytod = -tod.copy()

# Remove offsets first usingg median (here we just want to have all scans at the same leveel before decorrelating from azimuth)
mytod = remove_offset_scan(mytod, scantype, method='median')

### Profiling in Azimuth and elevation
n_el = 20
el_lims = np.linspace(np.min(el)-0.0001, np.max(el)+0.0001, n_el+1)
el_av = 0.5 * (el_lims[1:] + el_lims[:-1])

okall = np.abs(scantype) > 0 
okpos = scantype > 0 
okneg = scantype < 0 
oks = [okpos, okneg]
oks_names = ['+ scans', '- scans']
minaz = np.min(azt[okall])
maxaz = np.max(azt[okall])
xaz = np.linspace(minaz, maxaz, 100)

degree = 3
coefficients = np.zeros((2, n_el, degree+1))
for i in range(len(oks)):
    subplot(1,2,i+1)
    xlabel('Azimuth [deg]')
    ylabel('Mode of TOD')
    for j in range(n_el):
        ok = oks[i] & (elt >= el_lims[j]) & (elt < el_lims[j+1])
        xc, yc, dx, dy, _ = ft.profile(azt[ok], mytod[ok], rng=[minaz, maxaz], nbins=50, mode=True, dispersion=True, plot=False)
        z = polyfit(xc, yc, degree, w=1./dy)
        p = np.poly1d(z)
        coefficients[i,j,:] = z
        pl = errorbar(xc, yc, yerr=dy, xerr=dx, fmt='o')
        plot(xaz, p(xaz), color=pl[0].get_color(), label = oks_names[i] + ' - El = {0:5.1f}'.format(np.mean(elt[ok])))
    legend()
show()

### Now interpolate this to remove it to the data
nscans = np.max(np.abs(scantype))
for i in range(1, nscans+1):
    okp = scantype == i
    okn = scantype == (-i)
    for ok in [okp, okn]:
        the_el = np.median(elt[ok])
        myp = np.poly1d([np.interp(the_el, el_av, coefficients[0,:,i]) for i in arange(degree+1)])
        mytod[ok] -= myp(azt[ok])
### And interpolate for scantype==0 regions
bad_chunks = get_chunks(mytod, scantype, 0)
mytod = linear_rescale_chunks(mytod, bad_chunks, sz=100)
    

# remove offsets again but this time with mode method as it appears to be less affected 
# by the presence of the peaks (no underestimation of the offset resultingg is shadow around the peaks)
mytod = remove_offset_scan(mytod, scantype, method='mode')

figure()
plot(tt[scantype>0], mytod[scantype>0], '.', label='Scan +')
plot(tt[scantype<0], mytod[scantype<0], '.', label='Scan +')
plot(tt[scantype==0], mytod[scantype==0], '.', label='Bad')
xlim(0,1000)
ylim(-30000, 30000)
legend()
show()


### Then make the maps
mapsb, mapcount = healpix_map(azt[scantype != 0], elt[scantype != 0], mytod[scantype != 0], nside=nside)
mapsb_pos, _ = healpix_map(azt[scantype > 0], elt[scantype > 0], mytod[scantype > 0], nside=nside)
mapsb_neg, _ = healpix_map(azt[scantype < 0], elt[scantype < 0], mytod[scantype < 0], nside=nside)
```

```{python}
unseen = (mapsb == hp.UNSEEN) | (mapsb_pos == hp.UNSEEN) | (mapsb_neg == hp.UNSEEN)

### Average of back and Forth
mapav = (mapsb_pos + mapsb_neg)/2
mapav[unseen] = hp.UNSEEN

### Difference of back and Forth
mapdiff = (mapsb_pos - mapsb_neg)
mapdiff[unseen] = hp.UNSEEN

### Difference of All and Av
mapdiff2 = (mapav - mapsb)
mapdiff2[unseen] = hp.UNSEEN

nlo = 3
nhi = 3
reso = 12
mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=-nlo*ss, max=nhi*ss)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=-nlo*ss, max=nhi*ss)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=-nlo*ss, max=nhi*ss)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=-nlo*ss, max=nhi*ss)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=-nlo*ssd, max=nlo*ssd)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=-nlo*ssd, max=nlo*ssd)


figure()
mini = -np.max(mapsb[~unseen])/10
maxi = np.max(mapsb[~unseen])*0.8

mm, ss = ft.meancut(mapsb[~unseen], 3)
hp.gnomview(mapsb, rot=[0,50], reso=reso, sub=(2,3,1), title=anatype+'\n Both scans $\sigma$ = {0:5.3g}'.format(ss), min=mini, max=maxi)
mmp, ssp = ft.meancut(mapsb_pos[~unseen], 3)
hp.gnomview(mapsb_pos, rot=[0,50], reso=reso, sub=(2,3,2), title=anatype+'\n Pos scans $\sigma$ = {0:5.3g}'.format(ssp), min=mini, max=maxi)
mmn, ssn = ft.meancut(mapsb_neg[~unseen], 3)
hp.gnomview(mapsb_neg, rot=[0,50], reso=reso, sub=(2,3,3), title=anatype+'\n Neg scans $\sigma$ = {0:5.3g}'.format(ssn), min=mini, max=maxi)
mma, ssa = ft.meancut(mapav[~unseen], 3)
hp.gnomview(mapav, rot=[0,50], reso=reso, sub=(2,3,4), title=anatype+'\n Av of Both scans $\sigma$ = {0:5.3g}'.format(ssa), min=mini, max=maxi)
mmd, ssd = ft.meancut(mapdiff[~unseen], 3)
hp.gnomview(mapdiff, rot=[0,50], reso=reso, sub=(2,3,5), title=anatype+'\n Diff of both scans $\sigma$ = {0:5.3g}'.format(ssd), min=mini, max=maxi)
mmd2, ssd2 = ft.meancut(mapdiff2[~unseen], 3)
hp.gnomview(mapdiff2, rot=[0,50], reso=reso, sub=(2,3,6), title=anatype+'\n Both - Av $\sigma$ = {0:5.3g}'.format(ssd2), min=mini, max=maxi)

```

```{python}

```

```{python}

```

```{python}

```

```{python}

```
