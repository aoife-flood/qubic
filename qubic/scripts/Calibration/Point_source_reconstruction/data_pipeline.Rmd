---
jupyter:
  jupytext:
    text_representation:
      extension: .Rmd
      format_name: rmarkdown
      format_version: '1.2'
      jupytext_version: 1.7.1
  kernelspec:
    display_name: Python [conda env:py36env] *
    language: python
    name: conda-env-py36env-py
---

# Pipeline for reconstruction point source from raw data


Data used for JCh 

* 130GHz-2019-04-18
* 140GHz-2019-04-10
* 150GHz-2019-03-31 o 150GHz-2019-04-06
* 160GHz-2019-04-08
* 170GHz-2019-04-14


**Data measured** taken from CCA: `/sps/qubic/Data/Calib-TD`

* If you are working in your personal machine, you can copy the dataset doing, in a terminal: 

&nbsp;&nbsp;&nbsp;&nbsp;`scp -r mgamboa@cca.in2p3.fr:/sps/qubic/Data/Calib-TD/2019-04-06 .`

and you get a directory called `2019-04-06` in your current directory. It tooks more than 20 minutes (depens on your network speed and others probably) and size aprox 2GB. 

**Data calibration source** taken from CCA: `/sps/qubic/Data/Calib-TD/calsource`

* If you are working in your personal machine, you can copy the dataset doing, in a terminal: 

&nbsp;&nbsp;&nbsp;&nbsp;`scp -r mgamboa@cca.in2p3.fr: /sps/qubic/Data/Calib-TD/calsource/*20190406* .`

```{python}
# %matplotlib inline
# Importation modules
import os
import sys
import glob
import inspect
from importlib import reload

import scipy.ndimage.filters as f
import healpy as hp
import pickle
from matplotlib import rc
import matplotlib.pyplot as plt
from matplotlib import rc
rc('figure', figsize=(15,8))
rc('font', size=12)
rc('text', usetex=False)
rc('image', cmap='viridis')

import qubic
from qubicpack.qubicfp import qubicfp
import qubic.io
from pysimulators import FitsArray
import qubic.fibtools as ft
import qubic.demodulation_lib as dl
import qubic.sb_fitting as sbfit
import qubic.SpectroImLib as si
import qubic.selfcal_lib as sc

## Import jchinstrument from ../
#current_dir = os.path.dirname(os.path.abspath(inspect.getfile(inspect.currentframe())))
#parent_dir = os.path.dirname(current_dir)
#sys.path.insert(0, parent_dir) 
#import jchinstrument as jcinst

#global_dir = Qubic_DataDir(datafile='instrument.py', datadir=os.environ['QUBIC_DATADIR'])
```

**1st)** Use `fit_sb` from `demodulation_lib` module from `qubicsoft` package. 

Output files in: `/home/mgamboa/qubic/QUBIC/qubiccalibration/Data/150GHz-2019-04-06/[Flat, Healpix]`

script used: `Analyse-Scan-2020-01-15-MemorySave.Rmd` and `Sample_Demodulation`

```{python}
# Setup
verbose = False
savedirtest = '/home/martin/pruebas/qubicpipe/'
# Read data
day = '2020-03-16'
keyword = '*ScanFast*'
data_dir = '/home/martin/QUBIC/qubiccalibration/Data/Calib-TD/'+day+'/'
dirs = np.sort(glob.glob(data_dir + keyword))
```

```{python}
# Create focal plane object 
QubicFP = qubicfp()
QubicFP.read_qubicstudio_dataset(dirs[3])
if verbose: QubicFP.read_qubicstudio_dataset(dirs[3])
```

```{python}
time_azel = QubicFP.timeaxis(datatype = 'hk', axistype = 'pps')
az = QubicFP.azimuth()
el = QubicFP.elevation()

t0 = time_azel[0]
plt.plot(az, el)
```

```{python}
confg = 'new'
if confg == 'new':
    t_src = QubicFP.calsource()[0]
    data_src = QubicFP.calsource()[1]
elif confg == 'old':
    def read_cal_src_data(file_list, time_offset=7200):
        ttsrc_i = []
        ddsrc_i = []
        for ff in file_list:
            thett, thedd = np.loadtxt(ff).T
            ttsrc_i.append(thett + time_offset)
            ddsrc_i.append(thedd)

        t_src = np.concatenate(ttsrc_i)
        data_src = np.concatenate(ddsrc_i)
        return t_src, data_src
    daycalsrc = "".join(str.split(day,'-'))
    fcalsrc = glob.glob( os.environ['QUBIC_TODDIR'] + "calsource/"+'*'+daycalsrc+'*.dat')
    fcalsrc.sort()

    t_src, data_src = read_cal_src_data(fcalsrc)
```

```{python}
TESNum = 95
asic = 1
tod = QubicFP.timeline(TES = TESNum, asic = asic)
tt = QubicFP.timeaxis(axistype = 'pps', asic = asic)

```

```{python}
rc('figure',figsize=(13,8))
#### Filtering
thefreqmod = 1.

period = 1./ thefreqmod
lowcut = 0.5
highcut = 20

xmin = 0.01
xmax = 90.
ymin = 1e1
ymax = 1e17

############ Power spectrum
spectrum_f, freq_f = ft.power_spectrum(tt, tod, rebin=True)
plot(freq_f, f.gaussian_filter1d(spectrum_f,1),label='Raw Data')
yscale('log')
xscale('log')
xlabel('Frequency [Hz]')
ylabel('Power Spectrum')
xlim(xmin, xmax)
ylim(ymin, ymax)
title('TES {} ASIC {}'.format(TESNum,asic))

for i in range(10):
    plot([1./period*i,1./period*i],[ymin,ymax],'k--',alpha=0.3)

plot([lowcut, lowcut],[ymin,ymax],'k')
plot([highcut, highcut],[ymin,ymax],'k')
legend()

########## New Power spectrum
nharm = 10
notch = np.array([[1.724, 0.005, nharm]])
newdata = ft.filter_data(tt, tod, lowcut, highcut, notch=notch, rebin=True, verbose=True, order=5)
spectrum_f2, freq_f2 = ft.power_spectrum(tt, newdata, rebin=True)
plot(freq_f2, f.gaussian_filter1d(spectrum_f2,1),label='Filtered data')
for i in range(nharm):
    plot([notch[0,0]*(i+1),notch[0,0]*(i+1)], [ymin,ymax],'m:')
legend(loc='upper left')

tight_layout()
```

```{python}
plot((tt-t0)/3600, dl.renorm(newdata), 
     label='Data TES {} ASIC {}'.format(TESNum,asic))
plot((t_src-t_src[0])/3600, dl.renorm(data_src)-5, label='source')
xlabel('Hours')
legend()
#title(thedir)
ylim(-20,20)

```

```{python}
##### Filtering to be used
lowcut = 0.5
highcut = 70
nharm = 10
notch = np.array([[1.724, 0.005, nharm]])
fourier_cuts = [lowcut, highcut, notch]

# Just to pick the shape 
temp_amps = dl.demodulate_methods([QubicFP.timeaxis(axistype = 'pps', asic = 1), 
                       QubicFP.timeline(TES = 1, asic = 1)], 
                      1./period, 
                      src_data_in = [tt, np.interp(tt, t_src, data_src)],
                      method = 'demod_quad', 
                      remove_noise = True,
                      fourier_cuts = fourier_cuts)[1]

amps_demod = np.zeros((256, len(temp_amps)))

for asic in [1,2]:
    tt = QubicFP.timeaxis(axistype = 'pps', asic = asic)
    src = [tt, np.interp(tt, t_src, data_src)]
    for i in range(128):
        print('Mapmaking for Asic {} TES {}'.format(asic, i + 1))    
        tod = QubicFP.timeline(TES = i + 1, asic = asic)

        print('- Demodulation')
        newt_demod, amps_demod[i+128*(asic-1),:], errors_demod = dl.demodulate_methods(
                                                                    [tt, tod],
                                                                    1./period, 
                                                                    src_data_in = src,
                                                                    method = 'demod_quad', 
                                                                    remove_noise = True,
                                                                    fourier_cuts = fourier_cuts)
```

```{python}
time_azel = QubicFP.timeaxis(datatype = 'hk', axistype = 'pps')
az = QubicFP.azimuth()
el = QubicFP.elevation()

newaz = np.interp(newt_demod, time_azel, az)
newel = np.interp(newt_demod, time_azel, el)
azmin = min(az)
azmax = max(az)
elmin = min(el)
elmax = max(el)
naz = 40
nel = 40
nmaps = 256
mapdata = np.zeros((nmaps, nel, naz))

mapdata, azmap, elmap = dl.coadd_flatmap(amps_demod, newaz, newel, 
                                        filtering = None,
                                        azmin = azmin, azmax = azmax, 
                                        elmin = elmin, elmax = elmax, 
                                        naz = naz, nel = nel)
```

```{python}
#saving azimuth and elevation
from pysimulators import FitsArray as fa
fa(azmap).save(savedirtest + 'Flat/azimuth.fits')
fa(elmap).save(savedirtest + 'Flat/elevation.fits')
```

```{python}
#Look at one map
TESNum = 95
ites = TESNum - 1
mm, ss = ft.meancut(mapdata[ites,:,:],3)
imshow(mapdata[ites,:,:], aspect = 'equal',
       extent = [np.cos(np.radians(50)) * azmin, 
                 np.cos(np.radians(50)) * azmax, 
                 elmin, 
                 elmax],
       vmin = 0, vmax = 2e6)
title('TES {}'.format(ites+1))
```

All TES. Save flat maps in files. 

from James's notebook `Examples_notebooks/Sample_Demodulation.Rmd`

carefull with the demodulation, sometimes the the asics will have different demodulate lengths which may cause an issue here. the simple solution is to demodulate each asic separately and combine later

doing this part can probably be improved. I think with jupyter only one core is used. Maybe somebody already knows how to multithread with jupyter, please tell!

```{python}
"""save the maps
you can see the numbering here doesn't really reflect the real naming of TES we use"""

for i in range(256):
    print("saving flat map for tes {}".format(i+1))
    FitsArray(mapdata[i,:,:]).save(savedirtest+'Flat/imgflat_TESNum_{}.fits'.format(i+1))    
    FitsArray(mapdata[i,:,:]).save(savedirtest+'Flat/imgflat_TESNum_{}.fits'.format(i+1))
```

Test load the maps...ok!


flattest = np.zeros([nmaps, nel, naz])
flattest[0,:,:], az, el = sbfit.get_flatmap(256, savedirtest, 
                                     azmin = azmin, azmax = azmax, 
                                     remove = None)
imshow(flattest[0,:,:], aspect = 'equal',
       extent = [np.cos(np.radians(50)) * azmin, 
                 np.cos(np.radians(50)) * azmax, 
                 elmin, 
                 elmax],
      vmin=0, vmax=2.e6)


**2nd)** Once we have the flat/*helapy* maps we fit the position of the peaks for each TES. To do that we can select between fitting symetric gaussian or asymetric (`sym` or `asym`) for each peak.

```{python}
keys_sym = ['xc', 'yc', 'dist', 'angle', 'distx', 'disty', 'ampgauss', 
            'xcgauss', 'ycgauss', 'fwhmgauss', 'fwhmpeaks']

keys_asym = ['xc', 'yc', 'dist', 'angle', 'distx', 'disty', 'ampgauss', 
            'xcgauss', 'ycgauss', 'fwhmgauss']
for i in range(9):
    keys_asym.append('fwhmxpeak_{}'.format(i))
for i in range(9):
    keys_asym.append('fwhmypeak_{}'.format(i))
for i in range(9):
    keys_asym.append('rhopeak_{}'.format(i))
```

```{python}
import debugging_fit as df
```

```{python}
reload(df)
flat_map, azinit, elinit, fitout, xxyynew = df.fit_sb(93, savedirtest)
```

```{python}
import iminuit
help(iminuit.Minuit)
```

```{python}
sbfitmodel = sbfit.SbModelIndepPeaks(nrings=2, common_fwhm=True, 
                                 no_xy_shift=False, distortion=False)
detnums = [1,2,3,4]
if verbose: 
    print('Using Fit Model {} for TES #{}'.format(sbfitmodel.name,detnums[i]))

flattest, az, el = sbfit.get_flatmap(detnums[1], savedirtest, azmin = azmin, azmax = azmax, remove = None)
figure()
fit, thexypeaks = sbfit.fit_sb(flattest, az, el, sbfitmodel, resample=False, newsize=70,
                               verbose=True, doplot=True, 
                               extra_title='TES #{}'.format(detnums[1]))
```

```{python}
# Read the data
for TESNum in range(1, 257):
    print(TESNum)
    flatmap, az, el = sbfit.get_flatmap(TESNum, savedirtest, remove=None, azmin=azmin, azmax=azmax)

    #### Instantiate a model
    sbfitmodel3 = sbfit.SbModelIndepPeaks(nrings=2, common_fwhm=True, no_xy_shift=False, distortion=False)
    
    fit, xypeaks = sbfit.fit_sb(flatmap, az, el, sbfitmodel3, verbose=False, resample=False, 
                            doplot=False, extra_title='TES #{}'.format(TESNum))
```

```{python}
GaussianShape = 'sym'
if GaussianShape == 'sym':
    funcfit = dl.fit_sb
elif GaussianShape == 'asym':
    funcfit = dl.fit_sb_asym
```

```{python}
flatmap_init, az_init, el_init = sbfit.get_flatmap(2, dirfiles)
flatmap = flatmap_init
az = az_init
el = el_init
az2d, el2d = np.meshgrid(az * np.cos(np.radians(50)), np.flip(el))
distance_max = 5.
az_center=0.
el_center=50.
scaling=140e3
mask = (np.sqrt((az2d - az_center) ** 2 + (el2d - el_center) ** 2) < distance_max).astype(int)
wmax = np.where((flatmap * mask) == np.max(flatmap * mask))
maxval = flatmap[wmax][0]
x = [az2d, el2d]
parsinit = np.array([az2d[wmax][0], el2d[wmax][0], 8.3, 44., 0., 0.009, maxval / scaling, 0., 50., 13., 1.])
rng = [[az2d[wmax][0] - 1., az2d[wmax][0] + 1.],
           [el2d[wmax][0] - 1., el2d[wmax][0] + 1.],
           [8., 8.75],
           [43., 47.],
           [-0.02, 0.02],
           [-0.02, 0.02],
           [0, 1000],
           [-3, 3],
           [47., 53],
           [10., 16.],
           [0.5, 1.5]]

```

```{python}
fit = ft.do_minuit(x, np.ravel(flatmap / scaling), np.ones_like(np.ravel(flatmap)), parsinit,
                       functname=dl.flattened_qubic_sb_model, chi2=ft.MyChi2_nocov, rangepars=rng,
                       force_chi2_ndf=True)

```

```{python}
machine = os.uname()[1]
dirfreq = "150GHz-2019-04-06/"
if machine == 'shaka':
	dirallfreqs = "/home/mgamboa/qubic/QUBIC/qubiccalibration/Data/"
elif machine == 'hain':
	dirallfreqs = "/home/martin/QUBIC/qubiccalibration/Data/Calib-TD/"

dirfiles = dirallfreqs+dirfreq
dirsave = dirallfreqs+dirfreq+"FitSB/"

ft.printnow("====================================")
ft.printnow("====================================")
ft.printnow("Starting \n")
ft.printnow("====================================")
ft.printnow("====================================")

t0 = time.time()

for TESIndex in range(2):
    TESNum = TESIndex+1
    if GaussianShape == 'sym':
        flatmap, az, el, fit, xypeaks = dl.fit_sb(TESNum, dirfiles)
    elif GaussianShape == 'asym':
        flatmap, az, el, fit, xypeaks = dl.fit_sb_asym(TESNum, dirfiles)
    
    FitsArray(fit[1]).save(dirsave+'/fit_sb_{}_TESNum_{}.fits'.format(
        GaussianShape, TESNum))
    FitsArray(fit[2]).save(dirsave+'/errfit_sb_{}_TESNum_{}.fits'.format(
        GaussianShape, TESNum))
    ft.printnow("Done (sym) TES = {}".format(TESIndex+1))
    
t1 = time.time()
ft.printnow("====================================")
ft.printnow("====================================")
ft.printnow("Sym done in {:.2f} \n".format((t1 - t0)/60  ))
ft.printnow("====================================")
ft.printnow("====================================")

t2 = time.time()

```

**3rd)** Once we had create the flat and healpix maps, we have our demodulated data. We now read it doing

```{python}
# INSTRUMENT
ns = 256
d = qubic.qubicdict.qubicDict()
d.read_from_file('global_source_oneDet_multiband.dict')

print(d['kind'])
d['kind']='I'
print(d['kind'])
d['nside']=ns

fittedpeakfile = os.environ['QUBIC_TODDIR'] + '150GHz-2019-04-06/FitSB/fitted_peaks.fits'
directory = os.environ['QUBIC_TODDIR'] + '150GHz-2019-04-06/'
```

```{python}
c50 = np.cos(np.radians(50))
azmin = -15./c50
azmax = 15./c50
flatmap, az, el = sbfit.get_flatmap(1, directory, azmin=azmin, azmax=azmax)
npix = len(np.ravel(flatmap))
alldata_renorm = np.zeros((256, npix))
for i in range(256):
    flatmap, az, el = sbfit.get_flatmap(i+1, directory, azmin=azmin, azmax=azmax)
    mm,ss = ft.meancut(flatmap,3)
    alldata_renorm[i,:] = np.ravel((flatmap-mm)/ss)  

med = np.reshape(np.median(alldata_renorm,axis=0),np.shape(flatmap))
mm = np.mean(med)
ss = np.std(med)

plt.rc('figure', figsize=(15,8))
plt.imshow(np.reshape(med, np.shape(flatmap)),
       extent=[np.min(az)*c50, np.max(az)*c50, np.min(el), np.max(el)], aspect='equal')
plt.colorbar()
plt.title('Median over all S.B. images (renormalized)')
```

```{python}

```
